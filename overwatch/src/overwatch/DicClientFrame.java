package overwatch;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;

public class DicClientFrame extends JFrame {
	private Socket socket = null;
	private JTextField eng1 = new JTextField(10);
	private JTextField kor1 = new JTextField(10);
	private JButton searchBtn = new JButton("찾기");
	private JTextArea log = new JTextArea(5,25);
	private JLabel imageLable = new JLabel();

	BufferedReader in = null;
	BufferedWriter out = null;

	public DicClientFrame() {
		super("클라이언트");
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		Container c = getContentPane();
		c.setLayout(new FlowLayout());
		c.add(new JLabel("영어"));
		c.add(eng1);
		c.add(new JLabel("한글"));
		c.add(kor1);
		c.add(searchBtn);
		c.add(new JScrollPane(log), BorderLayout.CENTER);
		c.add(imageLable, BorderLayout.NORTH);

		try {
			setupConnection();
		} catch (IOException e) {
			handleError(e.getMessage());
		}
		searchBtn.addActionListener(new MyActionListener1());

		setSize(400, 500);
		setVisible(true);
		startService();

	}

	private void startService() {
		ServerThread server = new ServerThread();
		server.start();
	}
	
	
	private void drawImage(String file) {
		ImageIcon icon = new ImageIcon(file);
		imageLable.setIcon(icon);
		this.pack();
	}
	
	private class ServerThread extends Thread {
		
		@Override
		public void run() {
			BufferedInputStream fin = null;
			BufferedOutputStream fout = null;
			ServerSocket listener = null;
			Socket socket = null;
			String saveFileName = null;
			try {
				listener = new ServerSocket(9998);
			} catch (IOException e1) {
				e1.printStackTrace();
			} // 서버 소켓 생성
			 
		while(true) {
				try {	
					socket = listener.accept(); // waiting client connection
					log.setText("연결됨\n");
					fin = new BufferedInputStream(socket.getInputStream()); // 클라이언트로부터의 입력 스트림
					int cmd;
					String fileName = null;
					long length=0;
					
					cmd = fin.read();
					if (cmd == Command.FILE_NAME) { // FILE_NAME 명령 수신
						int nameSize = receiveInt(fin); // 파일 이름 크기
						log.append("전송받은 파일 이름 길이 :" + nameSize + "\n");
						byte fname[] = new byte[nameSize];
						fin.read(fname); 
						fileName = new String(fname);
						log.append("전송받은 파일 이름:" + fileName + "\n");
						saveFileName = "copy_" + fileName;
						log.append("저장할 파일 이름:" + saveFileName + "\n");
						fout = new BufferedOutputStream(new FileOutputStream(saveFileName));
					} else {
						log.append("명령 수신 오류" + cmd + "\n");
						socket.close(); // 클라이언트와 통신용 소켓 닫기
						listener.close(); // 서버 소켓 닫기
						return;
					}
					cmd = fin.read();
					if (cmd == Command.FILE_SIZE) { // FILE_SIZE 명령 수신
						int lenghLow = receiveInt(fin); // 파일 크기의 하위 4바이트
						int lenghHigh = receiveInt(fin); // 파일 크기의 상위 4바이트
						length = lenghHigh;
				     	length <<= 32; // 상위 바이트로 만들기 위해 32비트 쉬프트
						length += lenghLow; // 하위 4 바이트 더하기
						log.append("전송받은 파일 크기:" + length + "\n");
					} else {
						log.append("명령 수신 오류" + cmd + "\n");
						if (fout != null)
							fout.close();
						socket.close(); // 클라이언트와 통신용 소켓 닫기
						listener.close(); // 서버 소켓 닫기
						return;
					}
					cmd = fin.read();
					if (cmd == Command.SEND_BEGIN) {
						int numberToRead;
						while (length >0) {
							byte b[] = new byte[2048];
							if (length < b.length) 
								numberToRead = (int)length;
							else
								numberToRead = b.length;
							int numRead = fin.read(b, 0, numberToRead);
							if (numRead <= 0) { 
								if (length > 0) { // 더 이상 읽을 것이 없는데 아직 파일 크기만큼 못 읽은 경우
									log.append("전송 오류가 발생했습니다. 읽은 바이트: " + numRead + " 남은 바이트:" + length + "\n");
									break;
								}
							} else {
								log.append("."); // 진행 상태 표시 
								fout.write(b, 0, numRead);
								length -= numRead;
							}
						}
						cmd = fin.read();
						if (cmd == Command.SEND_END) { // SEND_END 명령
							log.append("\n파일 수신 성공. 현재 폴더에 저장되었습니다.\n");
						} else {
							log.append("\n명령 수신 오류" + cmd + "\n");
						}
						if (fout != null)
							fout.close();
						socket.close(); // 클라이언트와 통신용 소켓 닫기					
						drawImage(saveFileName);
					}
				} catch (IOException e) {
					e.printStackTrace();
					log.append("파일 수신 중 오류가 발생했습니다.\n");
				}
			} // end of while
		}

	}

	private int receiveInt(BufferedInputStream fin) throws IOException {
		int value;
		value = fin.read();
		value |= fin.read() << 8;
		value |= fin.read() << 16;
		value |= fin.read() << 24;
		return value;
	}

	private void handleError(String string) {
		System.out.println(string);
		System.exit(1);
	}

	private void setupConnection() throws IOException {
		socket = new Socket("localhost", 9999);
		System.out.println("연결됨");
		in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
		out = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
	}

	class MyActionListener1 implements ActionListener {
		@Override
		public void actionPerformed(ActionEvent e) {
			try {
				out.write(eng1.getText() + "\n");
				out.flush();
				String text = in.readLine();
				kor1.setText(text);
			} catch (IOException e2) {
				handleError(e2.getMessage());
			}
		}
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		new DicClientFrame();
	}

}